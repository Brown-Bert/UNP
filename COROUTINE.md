注：tcp通信，客户端发送数据，服务器接收数据，客户端使用write发送数据，多次调用write可能在底层封装成一个分节发送，也可能一个write一个分节发送，服务器调用read读取数据，只要调用read的时候来了的数据，只要数据没超过BUFSIZE都全部读上来
# 协程的起源
同步与异步都是基于epoll实现的，不同之处在于，epoll监听到通信事件的时候，是一个一个处理，还是把任务下发给不同的线程处理
## 同步的问题（单线程）
同步实现起来简单，但短板也很明显，单线程操作耗时是最严重的，其次epoll监听事件每一轮处理，就会出现在处理每一轮结束后才会回到eoll_wait，如果处理过程中来了大量事件，就会全部拥堵在epoll_wait，如果描述符再采用的是阻塞模式，在每一轮处理过程中有些通信阻塞在IO的话，就会使每一轮的处理时间更加延长
## 异步的问题（多线程）
异步实现起来复杂，epoll把监听的事件分发给线程池中的某一个线程处理，epoll照样是是一轮一轮的处理，大概率会出现不同的轮次当中，那么就会出现多个线程管理同一个描述符的情况，如果读取管道的描述符采用的是阻塞模式，那么就会出现一个线程阻塞在read，另一个线程收到对端关闭的通知，此时第一个线程就会报一个操作已关闭或者不存在的描述符的错
# 协程案例